<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="NEXTB">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="NEXTB">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NEXTB">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> NEXTB </title>
</head>


<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">NEXTB</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/09/factory/" itemprop="url">
                  不是学习工厂模式最简单的指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-09T09:53:29+08:00" content="2016-11-09">
              2016-11-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/09/factory/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/09/factory/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/09/factory/" class="leancloud_visitors" data-flag-title="不是学习工厂模式最简单的指南">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>工厂模式，简单的理解，就是封装通过new方式创建对象的代码。工厂模式可分为三类：</p>
<blockquote>
<p>简单工厂（Simple Factory）<br>工厂方法（Factory Method）<br>抽象工厂（Abstract Factory）</p>
</blockquote>
<p>本文的目的，就是通过举例理解区分三种工厂模式。</p>
<h1 id="没有工厂模式"><a href="#没有工厂模式" class="headerlink" title="没有工厂模式"></a>没有工厂模式</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>如果用户要购买Iphone手机，在没有工厂模式的情况下，用户只能自己根据手机型号来创建手机，客户代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">(String type)</span> </span>{
         <span class="keyword">switch</span> (type) {
            <span class="keyword">case</span> <span class="string">"iphone5"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone5();
            <span class="keyword">case</span> <span class="string">"iphone6"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当现在需要把ipone5下架，推出iphone6时，Customer代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">(String type)</span> </span>{
         <span class="keyword">switch</span> (type) {
            <span class="keyword">case</span> <span class="string">"iphone6"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
             <span class="keyword">case</span> <span class="string">"iphone7"</span>:
                 <span class="keyword">return</span> <span class="keyword">new</span> Iphone7();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre>
<p>简单的修改Customer端的代码，就能满足新的需求，但是，这违背了一个原则：</p>
<blockquote>
<p>设计应该”对扩展开发，对修改关闭”</p>
</blockquote>
<p>每次有新的型号，都需要改变Customer的代码，这明显是不合理，于是该普通工厂模式出现了。</p>
<h1 id="普通工厂"><a href="#普通工厂" class="headerlink" title="普通工厂"></a>普通工厂</h1><p>把创建手机变化的部分封装到一个新的类SimpleIphoneFactory，Customer代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">(String type)</span> </span>{
        SimpleIphoneFactory simpleIphoneFactory = <span class="keyword">new</span> SimpleIphoneFactory();
        <span class="keyword">return</span>  simpleIphoneFactory.creatIphone(type);
    }
}
</code></pre>
<p>SimpleIphoneFactory的代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIphoneFactory</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">creatIphone</span><span class="params">(String type)</span> </span>{
        <span class="keyword">switch</span> (type){
            <span class="keyword">case</span> <span class="string">"iphone6"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
            <span class="keyword">case</span> <span class="string">"iphone7"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone7();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre>
<p>改变后，感觉代码并没有太大的变化。当iphone6下架，iphone8上架，还是得改变SimpleIphoneFactory的代码。<br>但是，此时Customer的代码无须改动，<strong>简单工厂方法的目的，就是把具体实例化的代码，从客户端删除</strong>。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>当Iphone的型号越来越多时，SimpleIphoneFactory的代码依然需要改变，Customer类符合开闭原则，SimpleIphoneFactory不符合开闭原则。下面，我们采用工厂方法，把获取手机的方法getIphone()移回Customer，解决SimpleIponeFactory依赖过多Iphone实体对象的问题。</p>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>把用户变成抽象类，他的子类决定实例化什么类型的手机：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iphone <span class="title">getIphone</span><span class="params">()</span></span>;
}
</code></pre>
<p>Iphone5消费者：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone5Customer</span> <span class="keyword">extends</span> <span class="title">Customer</span></span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone5();
    }
}
</code></pre>
<p>Iphone6消费者：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone6Customer</span> <span class="keyword">extends</span> <span class="title">Customer</span></span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
    }e
}
</code></pre>
<p>下面来看不同用户获取手机的代码：</p>
<pre><code class="java"><span class="comment">//购买5的用户</span>
Customer iphone5Customer = <span class="keyword">new</span> Iphone5Customer();
iphone5Customer.getIphone();
<span class="comment">//购买6的用户</span>
Customer iphone6Customer = <span class="keyword">new</span> Iphone6Customer();
iphone5Customer.getIphone();
</code></pre>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>用户获取手机，是为了使用，我们给手机添加一个startUp()方法启动手机：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone</span> </span>{
    <span class="comment">/**
     * 电池毫安数
     */</span>
    <span class="keyword">protected</span> <span class="keyword">int</span> power;
    <span class="comment">/**
     * 电池
     */</span>
    <span class="keyword">protected</span> Battery battery;

    <span class="comment">/**
     * 设置电池
     * <span class="doctag">@param</span> battery
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBattery</span><span class="params">(Battery battery)</span></span>{
        <span class="keyword">this</span>.battery = battery;
    };

    <span class="comment">/**
     * 开机
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span></span>;
}
</code></pre>
<p>Iphone抽象类提供一个开机的抽象方法，由子类实现。我们开看Iphone5的实体类：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone5</span> <span class="keyword">extends</span> <span class="title">Iphone</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Iphone5"</span>;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(battery.power() == <span class="number">5000</span>){
            Log.d(TAG,<span class="string">"startUp success"</span>);
        }<span class="keyword">else</span>{
            Log.d(TAG,<span class="string">"Boom!!!!"</span>);
        }
    }
}
</code></pre>
<p>可以看到Iphone5实体类，当调用startUp方法时，需要判断电池的毫安数，当等于5000时，成功启动；否则会爆炸。Iphone依赖Battery,下面来看Battery抽象类：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Battery</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">()</span></span>;
}
</code></pre>
<p>抽象类定义了一个抽象power()方法，调用此方法返回电池的毫安数。来看Iphone5Battery和Iphone6Battery的类：</p>
<pre><code class="java"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Iphone5Battery</span> <span class="keyword">extends</span> <span class="title">Battery</span></span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="number">5000</span>;
    }
}

<span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Iphone6Battery</span> <span class="keyword">extends</span> <span class="title">Battery</span></span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="number">10000</span>;
    }
}
</code></pre>
<p>假设，用户把iphone5的手机配上iphone6的电池(假设电池外形一样，只是毫安数不一样)，代码如下：</p>
<pre><code class="java">Customer iphone5Customer = <span class="keyword">new</span> Iphone5Customer();
Iphone iphone5 = iphone5Customer.getIphone();
iphone5.setBattery(<span class="keyword">new</span> Iphone6Battery());
iphone5.startUp();
</code></pre>
<p>毫无疑问，这会发生爆炸。<code>Log.d(TAG,&quot;Boom!!!!&quot;)</code>。为了防止爆炸，生产手机时，必须要配套生产同类型的电池。<strong>当需要约束产品类之间的关系时</strong>，抽象工厂出场了。</p>
<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>Iphone稳定的产能，需要各个代工厂的生产，苹果公司制定了一套生产手机的框架来保证手机的质量，例如Iphone6的手机只能使用Iphone6的电池。苹果公司可不想像三星手机那样<strong>因电池原因</strong>发生爆炸事件。<br>我们修改Customer类如下：</p>
<pre><code class="java"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(IphoneFactory iphoneFactory)</span></span>{
        iphoneFactory.startUp();
    }
}
</code></pre>
<p>Customer类提供了一个启动手机的方法，传入一个IphoneFactory对象，由IphoneFactory创建手机和对应的电池，防止因电池型号不对导致的爆炸意外。<br>IphoneFactory类如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IphoneFactory</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iphone <span class="title">creatIphone</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Battery <span class="title">creatBattery</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span></span>{
         Iphone iphone = createIphone();
         Battery battery = createBattery();
         iphone.setBattery(battery);
         iphone.startUp();
    }
}
</code></pre>
<p>IphoneFactory是一个抽象类，startUp方法确定了Iphone和Battery的关系，子类实现创建Iphone和Battery的方法。看Iphone5Factory的类：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone5Factory</span> <span class="keyword">extends</span> <span class="title">IphoneFactory</span> </span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Iphone <span class="title">creatIphone</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone5();
    }
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Battery <span class="title">creatBattery</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone4Battery();
    }
}
</code></pre>
<p>最后我们来看启动Iphone5手机的代码：</p>
<pre><code class="java">IphoneFactory iphone5Factory = <span class="keyword">new</span> Iphone5Factory();
Customer customer = <span class="keyword">new</span> Customer();
customer.startUp(iphone5Factory);
</code></pre>
<p>可以看到，iphone5手机成功启动的Log。因为IphoneFactory封装了startUp的方法，明确了Iphone和Battery的关系，用户不能自主组装Iphone和Battery，防止了因装错电池导致事故的发生。</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p><img src="/images/factory_simple.png" alt="简单工厂"></p>
<h2 id="工厂方法-1"><a href="#工厂方法-1" class="headerlink" title="工厂方法"></a>工厂方法</h2><p><img src="/images/factory_method.png" alt="工厂方法"></p>
<h2 id="抽象工厂-1"><a href="#抽象工厂-1" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p><img src="/images/factory_abstract.png" alt="抽象工厂"></p>
<h1 id="一句话小结"><a href="#一句话小结" class="headerlink" title="一句话小结"></a>一句话小结</h1><p>简单工厂：将创建代码从客户端移至工厂类。<br>工厂方法：用继承的方式实现，一种产品对应一个工厂类。<br>抽象工厂：系统存在产品族，且产品之间存在关系。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/19/annotation/" itemprop="url">
                  Android编译时注解实践指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-19T17:32:05+08:00" content="2016-10-19">
              2016-10-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/19/annotation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/19/annotation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/19/annotation/" class="leancloud_visitors" data-flag-title="Android编译时注解实践指南">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android注解分为两种，一种是运行时注解，一种是编译时注解。RxJava就是运行时注解，而butterKnife和EventBus是编译时注解，啃代码的时候经常碰到注解，所以只能乖乖的学习。本文主要讲解演示如何在Android Studio上运行一个编译时注解的Demo，被注解的对象打印出该对象的信息。</p>
<h2 id="1-新建一个Java-Library项目"><a href="#1-新建一个Java-Library项目" class="headerlink" title="1.新建一个Java Library项目"></a>1.新建一个Java Library项目</h2><p>在Android Studio中先新建一个Android project。在Android project 中选中File-&gt;New-&gt;New Module…选择<strong>Java Library</strong>新建一个module。因为注解中用到Java库，所以必须要导入Java Library.<br><img src="/images/process_new_module.png" alt="新建Java Library"><br><img src="/images/process_java_library.png" alt="new Module..."></p>
<p>新建的Android项目名叫At(Annotation),Java Library名字是at2.<br><img src="/images/process_projcet_struct.png" alt="new Module..."></p>
<h2 id="2-编写注解类"><a href="#2-编写注解类" class="headerlink" title="2.编写注解类"></a>2.编写注解类</h2><p>在at2项目中，新建一个PrintInject，加入以下代码声明一个注解类，注解类的类型是@interface<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Author      :  yuanjunli</div><div class="line"> * Create Time :  2016/10/19 13:50</div><div class="line"> * Email       : 878715255@qq.com</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)  <span class="comment">//声明此类可以注解的对象</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)                                   <span class="comment">//编译时运行</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PrintInject &#123;                                     <span class="comment">//@interface声明</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;                                                <span class="comment">//定义有一个int参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法</p>
<h2 id="3-注册声明方法"><a href="#3-注册声明方法" class="headerlink" title="3.注册声明方法"></a>3.注册声明方法</h2><p>在他项目中，新建一个PrintInjectProcessor，键入以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"com.example.PrintInject"</span>)</div><div class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintInjectProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</div><div class="line">        Messager messager = processingEnv.getMessager();</div><div class="line">        <span class="keyword">for</span> (TypeElement te : annotations) &#123;</div><div class="line">            <span class="keyword">for</span> (Element e : roundEnv.getElementsAnnotatedWith(te)) &#123;</div><div class="line">                messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">"Printing: "</span> + e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@SupportedAnnotationTypes：指定该注解起作用的类；<br>@SupportedSourceVersion(SourceVersion.RELEASE_7)：指定jdk的版本；<br>AbstractProcessor：自定义的声明需要继承AbstractProcessor，重点实现process方法；<br>processingEnv：注解框架提供的工具集合，在此demo中取到message对象打印信息。打印的信息在android studio中<strong>Gradle Console</strong>切页中显示；<br>TypeElement：是注解的类型；<br>以上的代码就是获取所有自定义的注解并且通过<code>e.toString()</code>打印注解类的信息。</p>
<h2 id="4-创建路径文件"><a href="#4-创建路径文件" class="headerlink" title="4.创建路径文件"></a>4.创建路径文件</h2><p>在resources路径文件夹下创建一个META-INF文件夹，META-INF下面创建一个services文件夹，在里边创建一个javax.annotation.processing.Processor文件，此文件路径不能出错。在文件中写入注解路径的声明，本项目路径是<code>com.example.PrintInjectProcessor</code><br><img src="/images/process_resources_struct.png" alt="new Module..."><br>如图检查Processor放置的路径是否一样。</p>
<h2 id="5-生成编译注解at2的jar包"><a href="#5-生成编译注解at2的jar包" class="headerlink" title="5.生成编译注解at2的jar包"></a>5.生成编译注解at2的jar包</h2><p>经过以上操作，编写了一个<code>@PrintInject</code>的声明，当对象被@PrintInject声明时，在项目编译时就会打印对象的信息。接下来单独编译运行at2 这个module，导出该jar包。<br><img src="/images/process_jar.png" alt="new Module..."><br>在android studio 右侧打开Gradle切页，如果没有显示项目的gradle，点击gradle按钮编译一下，如上图，打开:at2-&gt;Tasks -&gt;build 双击里边的build文件。编译成功后会如下图所示在项目build-&gt;libs目录下生成一个at2.jar.<br><img src="/images/process_libs.png" alt="new Module..."></p>
<h2 id="6-demo测试"><a href="#6-demo测试" class="headerlink" title="6.demo测试"></a>6.demo测试</h2><p>将at2.jar copy 到at主项目的libs文件夹下，生成android项目时在app/build.gradle文件下有<code>compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</code>为自动导入jar。编写MainActivity代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@PrintInject</span>(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@PrintInject(1)</code>在方法onCreate()上添加注解，int参数为1。接着看编译运行demo后，message的输出并不在Message切页，也不知Log里边，是在<strong>Gradle Console</strong>下。需要注意，第一次运行项目的时候会有message输出，当再次运行时并没有，因为第二次无须再次编译，如果需要再次看到输出的信息，可以Build-&gt;Clean Project。<br><img src="/images/process_console.png" alt="new Module..."></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>以上就是编译注解demo的全部内容，并不涉及注解的深入使用，只在于跑通注解的流程。</p>
<h2 id="8-引用"><a href="#8-引用" class="headerlink" title="8.引用"></a>8.引用</h2><blockquote>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/43452969" target="_blank" rel="external">Android 打造编译时注解解析框架 这只是一个开始</a><br><a href="http://www.jianshu.com/p/252b0c16ffaa" target="_blank" rel="external">如何实现自定义Java编译时注解功能–初步印象</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/18/当把EventBus比喻成苹果卖手机/" itemprop="url">
                  当把EventBus比喻成苹果卖手机
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-18T09:45:50+08:00" content="2016-10-18">
              2016-10-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/18/当把EventBus比喻成苹果卖手机/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/18/当把EventBus比喻成苹果卖手机/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/18/当把EventBus比喻成苹果卖手机/" class="leancloud_visitors" data-flag-title="当把EventBus比喻成苹果卖手机">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>EventBus一直都知道这个库，但是没有接触，看到<a href="http://gold.xitu.io/entry/5783410fa633bd005b24e079" target="_blank" rel="external">国内 Top500 Android 应用分析报告</a>使用情况，觉得有必要掌握此库。EventBus是android的一个用于消息传递的库，属于订阅者模式，让发布者和订阅者解耦。本文通过对EventBus的使用，分析其内部实现。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>关于EventBus的使用不是本文的重点，EventBus的使用请查看<a href="http://www.jianshu.com/p/da9e193e8b03" target="_blank" rel="external">EventBus使用详解</a>。</p>
<h1 id="做个比喻"><a href="#做个比喻" class="headerlink" title="做个比喻"></a>做个比喻</h1><p>为了更好的理解EventBus这个库的流程，以下将根据下图做一个比喻。<br><img src="/images/eventbus_iphone.png" alt="new Module..."><br>如上图，EventBus充当苹果公司销售部的角色。当苹果公司(Publisher发布者)生产(调用post方法)出某一款手机(EventType)时，消息会传递到销售部，由销售部告诉用户（Subscriber订阅者）。例如用户想购买iphone8，该用户必须要预约(方法被@Subscriber注解)，当销售部接到公司说iphone8开始售卖了，那么只有预约手机的用户可以购买(订阅方法被调用)。</p>
<h1 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h1><h2 id="EventBus-getDefault-register-this"><a href="#EventBus-getDefault-register-this" class="headerlink" title="EventBus.getDefault().register(this);"></a>EventBus.getDefault().register(this);</h2><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>{
     <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) {
         <span class="keyword">synchronized</span> (EventBus.class) {
             <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) {
                 defaultInstance = <span class="keyword">new</span> EventBus();  <span class="comment">//调用默认构造函数构建单例</span>
             }
         }
     }
     <span class="keyword">return</span> defaultInstance;
 }
</code></pre>
<p>看new EventBus做了什么初始化工作：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>(DEFAULT_BUILDER);
    }
</code></pre>
<p>空构造函数引用带参数的构造函数，参数类型是EventBusBuilder：</p>
<pre><code class="java">EventBus(EventBusBuilder builder) {
       subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();
       typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();          
       stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();     
       mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);  
       backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);                    
       asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);            
       indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;    
       subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,
               builder.strictMethodVerification, builder.ignoreGeneratedIndex);
       logSubscriberExceptions = builder.logSubscriberExceptions;   
       logNoSubscriberMessages = builder.logNoSubscriberMessages;
       sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
       sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
       throwSubscriberException = builder.throwSubscriberException;
       eventInheritance = builder.eventInheritance;
       executorService = builder.executorService;
   }
</code></pre>
<p>通过使用默认构造器EventBusBuilder，默认配置了一些参数,部分重点参数会接下来在阅读源码中提到。</p>
<h3 id="register-Object-subscriber"><a href="#register-Object-subscriber" class="headerlink" title="register(Object subscriber)"></a>register(Object subscriber)</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>{
    Class&lt;?&gt; subscriberClass = subscriber.getClass();
    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }
}
</code></pre>
<p>调用register方法，可以看到参数是一个Object,EventBus支持Activity、Fragment、Service、BroadcastReceiver等之间传递消息。<br>调用subscriber.getClass()返回subscriber对象的运行时类的Java.lang.Class。<br>根据subscriber运行时的类获取该类所以的SubscriberMethod，就是该类被@Subscriber注解的所有方法。<br>通过循环该类所有的的被注解的方法，通过调用subscriber(subscriber, subscriberMethod)方法绑定subscriber和subscriberMethod的关系。</p>
<h3 id="subscribe-subscriber-subscriberMethod"><a href="#subscribe-subscriber-subscriberMethod" class="headerlink" title="subscribe(subscriber, subscriberMethod);"></a>subscribe(subscriber, subscriberMethod);</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>{
    <span class="comment">//获取subsrciberMethod传递的自定义EventType参数的运行时的类</span>
    Class&lt;?&gt; eventType = subscriberMethod.eventType;
    <span class="comment">//Subscription用于绑定subscriber和sucriberMethod,一个订阅者可以有多个subscriberMethod</span>
    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);
    <span class="comment">//根据EventType的运行时类取到该类所有的subscriptioins，subscriptionsByEventType是HashMap中的key</span>
    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) {
         subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();
         <span class="comment">//若根据EventType找不到subscriptions,则eventType作key,subscriptions作value添加到subscriptionByEventType中。</span>
         subscriptionsByEventType.put(eventType, subscriptions);
    } <span class="keyword">else</span> {
         <span class="keyword">if</span> (subscriptions.contains(newSubscription)) {
         <span class="comment">//已经存在newSubscription，抛出异常该订阅者已经注册，不可重复注册同一个subscriber</span>
             <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span>
                     + eventType);
         }
    }

    <span class="keyword">int</span> size = subscriptions.size();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) {
        <span class="comment">//循环subscriptions，根据标记优先级的priority从高到低，将新的subscription插入到subscriptions中</span>
        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {
            subscriptions.add(i, newSubscription);
            <span class="keyword">break</span>;
        }
    }
    <span class="comment">//typesBySubscriber是一个HashMap，根据subscriber做key,获取该subscriber对应的所有的订阅事件的类型</span>
    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
      <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) {
          subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();
          <span class="comment">//该订阅者之前的订阅事件类型列表为空，则将当前订阅类型添加到typesBySubscriber中</span>
          typesBySubscriber.put(subscriber, subscribedEvents);
      }
    subscribedEvents.add(eventType);
    <span class="comment">//如果该方法被标识为sticky事件</span>
    <span class="keyword">if</span> (subscriberMethod.sticky) {
         <span class="keyword">if</span> (eventInheritance) { eventInheritance标识是否考虑EventType的类层次结构
              <span class="comment">//循环所有的sticky黏性事件</span>
              Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
              <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
                  Class&lt;?&gt; candidateEventType = entry.getKey();
                  <span class="comment">//如果当前事件是其他事件的同类型的或者是他们的父类</span>
                  <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) {
                     Object stickyEvent = entry.getValue();
                     heckPostStickyEventToSubscription(newSubscription, stickyEvent);
                  }
              }
         } <span class="keyword">else</span> {
             Object stickyEvent = stickyEvents.get(eventType);
             checkPostStickyEventToSubscription(newSubscription, stickyEvent);
         }
    }
}
</code></pre>
<p>关键代码以上都有注释。<br>黏性事件，主要使用场景是：当订阅者尚未创建，先调用EventBus.getDefault().postSticky()方法发送一个sticky事件，该事件会被stickyEvents缓存起来，当订阅该事件的类调用register()方法时，同样可以收到该事件。而调用EventBus.getDefault().post()则必须先调用register()，才能收到事件。</p>
<h3 id="checkPostStickyEventToSubscription-newSubscription-stickyEvent"><a href="#checkPostStickyEventToSubscription-newSubscription-stickyEvent" class="headerlink" title="checkPostStickyEventToSubscription(newSubscription, stickyEvent);"></a>checkPostStickyEventToSubscription(newSubscription, stickyEvent);</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>{
        <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) {
            <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span>
            <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span>
            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
        }
    }
</code></pre>
<h3 id="跳转postToSubscription方法"><a href="#跳转postToSubscription方法" class="headerlink" title="跳转postToSubscription方法;"></a>跳转postToSubscription方法;</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>{
       <span class="comment">//根据@subscriber中threadMode进行区分，POSTING为当前线程执行，</span>
       <span class="comment">//MAIN为主线程，BACKGROUND为子进程，ASYNC为异步执行。</span>
       <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) {
           <span class="keyword">case</span> POSTING:
               invokeSubscriber(subscription, event);
               <span class="keyword">break</span>;
           <span class="keyword">case</span> MAIN:
               <span class="keyword">if</span> (isMainThread) {
                   invokeSubscriber(subscription, event);
               } <span class="keyword">else</span> {
                   mainThreadPoster.enqueue(subscription, event);
               }
               <span class="keyword">break</span>;
           <span class="keyword">case</span> BACKGROUND:
               <span class="keyword">if</span> (isMainThread) {
                   backgroundPoster.enqueue(subscription, event);
               } <span class="keyword">else</span> {
                   invokeSubscriber(subscription, event);
               }
               <span class="keyword">break</span>;
           <span class="keyword">case</span> ASYNC:
               asyncPoster.enqueue(subscription, event);
               <span class="keyword">break</span>;
           <span class="keyword">default</span>:
               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);
       }
   }
</code></pre>
<h3 id="invokeSubscriber-subscription-event"><a href="#invokeSubscriber-subscription-event" class="headerlink" title="invokeSubscriber(subscription, event)"></a>invokeSubscriber(subscription, event)</h3><p>下面我们来分析threadMode = ThreadMode.POSTING的情况,调用invokeSubscriber()方法，其他情况类似。</p>
<pre><code class="java"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>{
        <span class="keyword">try</span> {
            <span class="comment">//反射机制执行订阅的方法</span>
            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
        } <span class="keyword">catch</span> (InvocationTargetException e) {
            handleSubscriberException(subscription, event, e.getCause());
        } <span class="keyword">catch</span> (IllegalAccessException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);
        }
    }
</code></pre>
<h3 id="EventBus-getDefault-register-this-小结"><a href="#EventBus-getDefault-register-this-小结" class="headerlink" title="EventBus.getDefault().register(this)小结"></a>EventBus.getDefault().register(this)小结</h3><p>回到苹果公司卖手机的例子，EventBus.getDefault().register(this)中，this指的就是买手机的顾客，顾客通过调用此方法告诉销售部说我想登记买手机，登记的流程包括：<br>A.找到该用户所有的购买手机型号的预约信息(根据subscriber找到所有subscriberMethors<code>subscriberMethodFinder.findSubscriberMethods(subscriberClass)</code>);<br>B.将新登记的预约信息和之前的预约信息做比对，如果之前没有预约信息<code>subscriptions == null</code>，则添加到预约信息中；若之前有预约过的信息，检查是否有相同的预约信息（subscriber和subscriberMethod都一样）<code>subscriptions.contains(newSubscription)</code>，若有，则预约失败,并且丢给用户一个臭脸<code>throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;+ eventType);</code>。<br>C.添加到预约信息列表的时候，根据优先级由高到低，优先级相同插入到最后边的原则放入列表。<br>D.若用户想预约的手机不是新款手机，而是一款老手机<code>subscriberMethod.sticky=ture</code>，则无需预约，可直接购买。</p>
<h2 id="EventBus-getDefault-post-EventType"><a href="#EventBus-getDefault-post-EventType" class="headerlink" title="EventBus.getDefault().post(EventType);"></a>EventBus.getDefault().post(EventType);</h2><h3 id="post-和postSticky-的区别"><a href="#post-和postSticky-的区别" class="headerlink" title="post()和postSticky()的区别"></a>post()和postSticky()的区别</h3><p>发布者调用post(EventType）方法，若订阅者需要接收到此EventType，则订阅者必须要先注册并且注解接收此方法，否则收不到该方法；而调用postSticky(EventType),及时先发布者先发送消息，订阅者在注册事件，也能收到消息。<br>例如苹果公司出iphone8新款手机了，那么用户需要先预约手机，不预约的不能购买，此时苹果公司调用post(iphone8)方法；如果苹果公司推出的是一款旧手机iphone5,iphone5无须预约，顾客到店就可以直接购买，这时候调用postSticky(iphone5)方法。</p>
<h3 id="post-EventType"><a href="#post-EventType" class="headerlink" title="post(EventType);"></a>post(EventType);</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>{
        <span class="comment">//获取当前发送状态</span>
        PostingThreadState postingState = currentPostingThreadState.get();
        List&lt;Object&gt; eventQueue = postingState.eventQueue;
        <span class="comment">//将事件添加到列表中</span>
        eventQueue.add(event);
        <span class="comment">//如果当前不是在发送事件</span>
        <span class="keyword">if</span> (!postingState.isPosting) {
            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
            postingState.isPosting = <span class="keyword">true</span>;
            <span class="keyword">if</span> (postingState.canceled) {
                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);
            }
            <span class="keyword">try</span> {
            <span class="comment">//循环发送事件</span>
                <span class="keyword">while</span> (!eventQueue.isEmpty()) {
                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);
                }
            } <span class="keyword">finally</span> {
                postingState.isPosting = <span class="keyword">false</span>;
                postingState.isMainThread = <span class="keyword">false</span>;
            }
        }
    }
</code></pre>
<p>将当前发送事件添加到待处理的事件列表，如果当前不是在发送事件状态，则循环事件列表，调用<code>postSingleEvent(eventQueue.remove(0), postingState)</code>发送每一个事件。</p>
<h3 id="postSingleEvent-eventQueue-remove-0-postingState"><a href="#postSingleEvent-eventQueue-remove-0-postingState" class="headerlink" title="postSingleEvent(eventQueue.remove(0), postingState);"></a>postSingleEvent(eventQueue.remove(0), postingState);</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>{
       Class&lt;?&gt; eventClass = event.getClass();
       <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;
       <span class="comment">//当需要处理事件的继承关系时</span>
       <span class="keyword">if</span> (eventInheritance) {
           List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);
           <span class="keyword">int</span> countTypes = eventTypes.size();
           <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) {
               Class&lt;?&gt; clazz = eventTypes.get(h);
               subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
           }
       } <span class="keyword">else</span> {
           subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
       }
       <span class="keyword">if</span> (!subscriptionFound) {
           <span class="comment">//没有订阅该事件</span>
           <span class="keyword">if</span> (logNoSubscriberMessages) {
               Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);
           }
           <span class="comment">//如果该事件没有subscriber</span>
           <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;
                   eventClass != SubscriberExceptionEvent.class) {
               post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));
           }
       }
   }
</code></pre>
<p>主要处理调用postSingleEventForEventType()遇到的错误。</p>
<h3 id="postSingleEventForEventType"><a href="#postSingleEventForEventType" class="headerlink" title="postSingleEventForEventType()"></a>postSingleEventForEventType()</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>{
        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        <span class="comment">//根据eventType运行时的类找到所有的subscripitions</span>
            subscriptions = subscriptionsByEventType.get(eventClass);
        }
        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) {
            <span class="keyword">for</span> (Subscription subscription : subscriptions) {
                postingState.event = event;
                postingState.subscription = subscription;
                <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;
                <span class="keyword">try</span> {
                <span class="comment">//尝试将当前事件发生给订阅了该事件的订阅者</span>
                    postToSubscription(subscription, event, postingState.isMainThread);
                    aborted = postingState.canceled;
                } <span class="keyword">finally</span> {
                    postingState.event = <span class="keyword">null</span>;
                    postingState.subscription = <span class="keyword">null</span>;
                    postingState.canceled = <span class="keyword">false</span>;
                }
                <span class="keyword">if</span> (aborted) {
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
</code></pre>
<p>以上代码主要是将该事件传递给订阅了该事件的订阅者，每一个订阅者都尝试将该事件作为参数，调用所有的订阅的方法。</p>
<h3 id="post-方法小结"><a href="#post-方法小结" class="headerlink" title="post()方法小结"></a>post()方法小结</h3><p>以上逻辑并不复杂，就直接做比喻好了：<br>苹果公司发布iphone8的流程：<br>A.在发布iphone8的时候，先检查一下iphone8之前的手机是否都已经发布了，将iphone8添加到发布列表中；<br>B.若当前没有手机在发布流程中，则从发布列表中取出接下来待发布的手机，假设iphone8之前的都已经发布，那iphone8就进入发布流程;<br>C.根据iphone8找出所有iphone8的预约信息，预约了iphone8的用户可以购买手机;<br>D.处理特殊的情况：如果没有人预约，或者之前预约的人不购买。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上分析了EventBus的两个主要入口代码，做的比喻可能并不恰当，但应该能对理解源码的逻辑有很大的帮助。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><a href="http://p.codekk.com/blogs/detail/54cfab086c4761e5001b2538" target="_blank" rel="external">EventBus 源码解析</a><br><a href="http://skykai521.github.io/2016/02/20/EventBus-3-0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">EventBus 3.0 源代码分析</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/17/First设计模式思维导图/" itemprop="url">
                  Head First设计模式思维导图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-17T20:39:15+08:00" content="2016-10-17">
              2016-10-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/17/First设计模式思维导图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/17/First设计模式思维导图/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/17/First设计模式思维导图/" class="leancloud_visitors" data-flag-title="Head First设计模式思维导图">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这么多设计模式，看书经常看完后面的就把前面的忘记了。所以在读Head First时，特意边读边做笔记，用思维导图有利于描述设计模式之间的区别和联系。图不是很清晰，可以打开<a href="https://www.processon.com/view/link/57fdf69ae4b08d4fe9b94413" target="_blank" rel="external">Head First设计模式思维导图</a>查看大图。</p>
<p><img src="/images/design.png" alt="Head First设计模式思维导图"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="NEXT" />
          <p class="site-author-name" itemprop="name">NEXT</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NEXT</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"nextb"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("HOe9TkPiadv0Afw5jGl0gEuC-gzGzoHsz", "uPWanKlo8K6iWVB1KIajxCgk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

</body>
</html>
